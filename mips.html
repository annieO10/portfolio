<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>display VHDL code</title>
     <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>

     <link rel="stylesheet" href="./styles/styles.css">
</head>
<body>
    <header class="d-flex justify-content-center flex-column align-items-center"> 
        <section>
            <h1 class="name">Annie O'Connor</h1>
        </section>
        
        <section class="d-flex justify-content-center py-3">
            <ul class="nav nav-pills"> 
                <li class="nav-item">
                    <li class="nav-item"><a href="./index.html" class="nav-link">Home</a></li> 
                    <li class="nav-item"><a href="./about.html" class="nav-link">About</a></li>
                    <li class="nav-item"><a href="./SeniorDesign.html" class="nav-link">Senoir Design Project</a></li>
                    <li class="nav-item"><a href="./projects.html" class="nav-link active">Projects</a></li> 
                    <li class="nav-item"><a href="./resume.html" class="nav-link">Resume</a></li>
                    <li class="nav-item"><a href="./reflections.html" class="nav-link">Reflections</a></li>
                    
            </ul> 
        </section>
        
    </header>
    
    
    <pre class="p-3 border rounded bg-light"><code>
        -------------------------------------------------------------------------
-- Parnika Dasgupta and Annie O'Connor
-------------------------------------------------------------------------
-- MIPS_Processor.vhd
-------------------------------------------------------------------------
-- DESCRIPTION: This file contains an implementation of a MIPS_Processor  
-- implementation.
-- Skeleton code provided by Henry Duwe
-- Department of Electrical and Computer Engineering
-- Iowa State University
-------------------------------------------------------------------------


library IEEE;
use IEEE.std_logic_1164.all;
use work.BusArray_type.all;



entity MIPS_Processor is
  generic(N : integer := 32);
  port(iCLK            : in std_logic;
       iRST            : in std_logic;
       iInstLd         : in std_logic;
       iInstAddr       : in std_logic_vector(N-1 downto 0);
       iInstExt        : in std_logic_vector(N-1 downto 0);
       oALUOut         : out std_logic_vector(N-1 downto 0));
end  MIPS_Processor;
	
architecture structural of MIPS_Processor is

	component PCReg_N is

		generic(N: integer :=32);
		port(	iIn : in std_logic_vector(N-1 downto 0);
			iClk : in std_logic;
			iWrEn : in std_logic;
			iReset : in std_logic;
			oOut : out std_logic_vector(N-1 downto 0)
		);
	end component;
	
	component NBitRCarryAdder is 
		generic(N : integer := 32);
		port (
			i_A : in std_logic_vector(N-1 downto 0);
			i_B : in std_logic_vector(N-1 downto 0);
			i_Cin : in std_logic;
			S : out std_logic_vector (N-1 downto 0);
			Cout : out std_logic
		);
	end component;
 

	component instmem is 

		generic 
		(
			DATA_WIDTH : natural := 32;
			ADDR_WIDTH : natural := 10
		);
		port 
		(
			clk		: in std_logic;
			addr	        : in std_logic_vector((ADDR_WIDTH-1) downto 0);
			data	        : in std_logic_vector((DATA_WIDTH-1) downto 0);
			we		: in std_logic := '0';
			re	 	: in std_logic := '0';
			q		: out std_logic_vector((DATA_WIDTH -1) downto 0)
		);
	end component;

	component iF_ID is
	  port(i_CLK        : in std_logic;     -- Clock input
	       i_RST        : in std_logic;     -- Reset input
	       i_PCP4          : in std_logic_vector(31 downto 0);     -- Data value input
	       o_PCP4          : out std_logic_vector(31 downto 0);
	       i_imem          : in std_logic_vector(31 downto 0);
	       o_imem          : out std_logic_vector(31 downto 0);
	       i_stall	       : in std_logic;
	       i_pc_stall	: in std_logic;
	       o_pc_stall	: out std_logic);
	end component;

	component ControlUnit is 

		port(
			i_opcode : in std_logic_vector(5 downto 0);
			i_funct : in std_logic_vector(5 downto 0);
			o_RegDst : out std_logic;
			o_ALUSrc : out std_logic;
			o_MemtoReg : out std_logic;
			o_RegWrite : out std_logic;
			o_MemRead : out std_logic;
			o_MemWrite : out std_logic;
			o_PCSrc : out std_logic;
			o_ALUOp : out std_logic_vector(1 downto 0);
			o_Ext : out std_logic;
			o_jump : out std_logic;
			o_ijump : out std_logic;
			o_lb : out std_logic;
			o_lh : out std_logic;
			o_BranchCondition : out std_logic
		);
	end component;
	
	component mux2t1 is
	    port(i_S          : in std_logic;
	       i_D0         : in std_logic;
	       i_D1         : in std_logic;
	       o_O          : out std_logic);

	end component;
	
	component mux2t1_N is
 		generic(N : integer := 32); 
  		port(i_S          : in std_logic;
	       i_D0         : in std_logic_vector(N-1 downto 0);
	       i_D1         : in std_logic_vector(N-1 downto 0);
	       o_O          : out std_logic_vector(N-1 downto 0));

	end component;
	
	component ALUControl is

		port(	i_ALUOp : in std_logic_vector(1 downto 0);
			i_Funct : in std_logic_vector(5 downto 0);
			o_ALUCon : out std_logic_vector(3 downto 0)
		);
	end component;
	component Extender is 

		port(i_In    : in std_logic_vector(15 downto 0);           
		     i_C     : in std_logic;                               
		     o_O     : out std_logic_vector(31 downto 0));
	
	end component;
	component RegFile is
		generic(N : integer := 32);
		port(    i_WrAddr 	: in std_logic_vector(4 downto 0);	  -- write port; chooses which single 32-bit register to write to
		 	 i_WrEnable	: in std_logic;						  -- enables the write port to update register 
		 	 i_Data  	: in std_logic_vector(31 downto 0);   -- data to be written
		 	 i_CLK		: in std_logic;
		 	 i_Rst  	: in std_logic;
			 i_RAddr1 	: in std_logic_vector(4 downto 0); --Read 
		 	 i_RAddr2 	: in std_logic_vector(4 downto 0);
		 	 o_Rd1	 	: out std_logic_vector(31 downto 0);  -- read port 1
		 	 o_Rd2	 	: out std_logic_vector(31 downto 0)); -- read port 2
	end component;
	
	component ID_EX is
	  port(i_CLK        : in std_logic;     -- Clock input
	       i_RST        : in std_logic;     -- Reset input
	
	       i_MemtoRegEx          : in std_logic;
	       o_MemtoRegEx          : out std_logic;
	       i_RegWriteEx          : in std_logic;
	       o_RegWriteEx          : out std_logic;
	
	
	
	
	       i_memWriteEx          : in std_logic;
	       o_memWriteEx          : out std_logic;
	       i_memReadEx          : in std_logic;
	       o_memReadEx          : out std_logic;
	
	       i_branchEx          : in std_logic;
	       o_branchEx          : out std_logic;
	       i_zero          : in std_logic;
	       o_zero          : out std_logic;	
	       i_jumpEx          : in std_logic;	
	       o_jumpEx          : out std_logic;
	       i_AluSrcEx          : in std_logic;
	       o_AluSrcEx          : out std_logic;
	       i_ctlEx          : in std_logic;
	       o_ctlEx          : out std_logic;
	       i_jLinkEX          : in std_logic;
	       o_jLinkEX          : out std_logic;
	       i_jRegEX          : in std_logic;
	       o_jRegEX          : out std_logic;
		i_ALUOpEx : in std_logic_vector(3 downto 0);
		o_ALUOpEx : out std_logic_vector(3 downto 0);
		
	       i_halt          : in std_logic;
	       o_halt          : out std_logic;
	
		i_SoZEx		: in std_logic;
		o_SoZEx 	: out std_logic;
	
	       i_Reg1          : in std_logic_vector(31 downto 0);
	       o_Reg1          : out std_logic_vector(31 downto 0);
	       i_Reg2          : in std_logic_vector(31 downto 0);
	       o_Reg2          : out std_logic_vector(31 downto 0);
	
 	      i_PCEX          : in std_logic_vector(31 downto 0);	
 	      o_PCEX          : out std_logic_vector(31 downto 0);
	
 	      i_signExtend          : in std_logic_vector(31 downto 0);
 	      o_signExtend          : out std_logic_vector(31 downto 0);
	
		i_InstALU		: in std_logic_vector(31 downto 0);
		o_InstALU		: out std_logic_vector(31 downto 0);
	
 	      i_rs          : in std_logic_vector(4 downto 0);
 	      o_rs          : out std_logic_vector(4 downto 0);     
 	      i_rt          : in std_logic_vector(4 downto 0);
 	      o_rt          : out std_logic_vector(4 downto 0); 
	
 	      i_rd          : in std_logic_vector(4 downto 0);
 	      o_rd          : out std_logic_vector(4 downto 0);
		
		i_stall		: in std_logic
	);
 	      
	end component;
	component AddSub_N is
		generic(N : integer := 32);
		port(	 i_A			: in std_logic_vector(N-1 downto 0);
			 i_B			: in std_logic_vector(N-1 downto 0);
			 i_nAdd_Sub		: in std_logic_vector(3 downto 0);
			 i_shamt		: in std_logic_vector(4 downto 0);
	 		 o_Sums			: out std_logic_vector(N-1 downto 0);
			 o_Zero_Out		: out std_logic;
		 	 o_Carry_Out	        : out std_logic;
			 o_Overflow		: out std_logic
		);
	end component;


	component MEM_WB is
	  port(i_CLK        : in std_logic;     -- Clock input
	       i_RST        : in std_logic;     -- Reset input
	
	       i_MemtoRegM          : in std_logic;
	       o_MemtoRegM          : out std_logic;
	       i_RegWriteM          : in std_logic;
	       o_RegWriteM          : out std_logic;
	
	       i_memWriteM          : in std_logic;
	       o_memWriteM          : out std_logic;
	       i_memReadM          : in std_logic;
	       o_memReadM          : out std_logic;
	
	       i_halt          : in std_logic;
	       o_halt          : out std_logic;
	       i_jLinkM          : in std_logic;
	       o_jLinkM          : out std_logic;
	       i_OverflowM          : in std_logic;
	       o_OverflowM          : out std_logic;
		
	
	
	       i_PCM          : in std_logic_vector(31 downto 0);
	       o_PCM          : out std_logic_vector(31 downto 0);
	
	       i_ALU          : in std_logic_vector(31 downto 0);
	       o_ALU          : out std_logic_vector(31 downto 0);
	       i_ALU2          : in std_logic_vector(31 downto 0);
	       o_ALU2          : out std_logic_vector(31 downto 0);
	
	       i_Inst          : in std_logic_vector(4 downto 0);
	       o_Inst          : out std_logic_vector(4 downto 0)
	);
	       
	end component;

	component mem is

		generic 
		(
			DATA_WIDTH : natural := 32;
			ADDR_WIDTH : natural := 10
		);
	
		port 
		(
			clk		: in std_logic;
			addr	        : in std_logic_vector((ADDR_WIDTH-1) downto 0);
			data	        : in std_logic_vector((DATA_WIDTH-1) downto 0);
			we		: in std_logic := '0';
			re	 	: in std_logic := '0';
			q		: out std_logic_vector((DATA_WIDTH -1) downto 0)
		);

	end component;
	
	component EX_MEM is
	  port(i_CLK        : in std_logic;     -- Clock input
	       i_RST        : in std_logic;     -- Reset input
	
	       i_MemtoRegWB          : in std_logic;
	       o_MemtoRegWB          : out std_logic;
	       i_RegWriteWB          : in std_logic;
	       o_RegWriteWB          : out std_logic;
	
	       i_halt          : in std_logic;
	       o_halt          : out std_logic;
	       i_jLinkWB          : in std_logic;
	       o_jLinkWB          : out std_logic;
	       i_OverflowWB          : in std_logic;
	       o_OverflowWB          : out std_logic;
	
	       i_PCWB          : in std_logic_vector(31 downto 0);
	       o_PCWB          : out std_logic_vector(31 downto 0);
	
	       i_ALU          : in std_logic_vector(31 downto 0);
	       o_ALU          : out std_logic_vector(31 downto 0);
	       i_Dmem          : in std_logic_vector(31 downto 0);
	       o_Dmem          : out std_logic_vector(31 downto 0);
	
	       i_Inst          : in std_logic_vector(4 downto 0);
	       o_Inst          : out std_logic_vector(4 downto 0));
	       
	end component;


	--load
	signal s_IMemAddr : std_logic_vector(31 downto 0);
	signal s_NextInstAddr :std_logic_vector(31 downto 0);

	--PC
	signal s_WritePCEnL :std_logic;
	signal s_WritePCEn : std_logic;
	signal s_PC :std_logic_vector(31 downto 0);
	
	--InstMem
	signal s_InstIF :std_logic_vector(31 downto 0);
	--PCplus4
	signal s_PC4: std_logic_vector(31 downto 0);
	--fetch
	signal s_branchMUXresult :std_logic_vector(31 downto 0);
	signal s_jumpAddr : std_logic_vector(31 downto 0); 
	signal s_jumpMUXresult :std_logic_vector(31 downto 0);
	--haltID
	signal s_HaltID :std_logic;
	--IF/ID
	signal s_PC4ID  :std_logic_vector(31 downto 0);
	signal s_InstID :std_logic_vector(31 downto 0);
	signal s_WrEnIFID :std_logic;
	signal s_PCStallIFID :std_logic;
	--halt
	signal s_Halt :std_logic;
	--Control
	signal s_RegDst :std_logic;
	signal s_ALUsrc :std_logic;
	signal s_MemtoReg :std_logic;
	signal s_RegWrID :std_logic;
	signal s_MemRead :std_logic;
	signal s_MemWr :std_logic;
	signal s_PCSrc :std_logic;
	signal s_ALUOp :std_logic_vector(1 downto 0);
	signal s_Ext :std_logic;
	signal s_jump :std_logic;
	signal s_ijump :std_logic;
	signal s_lb :std_logic;
	signal s_lh :std_logic;
	signal s_Branch_Condition :std_logic;
	--signOunsigned
	signal s_unsignedOsigned :std_logic;

	--extend
	signal s_extendedimmediateID :std_logic_vector(31 downto 0);
	--MUX4ALUCon
	signal i_functOopcode :std_logic_vector(5 downto 0);
	--ALUCOn
	signal s_ALUCon : std_logic_vector(3 downto 0);
	--jalMUX
	signal s_jal :std_logic;
	signal s_instOjalresult :std_logic_vector(4 downto 0);
	--jalresultOinstMUX
	signal s_RegWrAddrID :std_logic_vector(4 downto 0);
	--Regfile
	signal s_rsDataID : std_logic_vector(31 downto 0);
	signal s_rtDataID : std_logic_vector(31 downto 0);
	signal s_rdDataWB :std_logic_vector(31 downto 0);
	--Branch
	signal s_Z :std_logic_vector(31 downto 0);
	signal s_Zero :std_logic;
	signal s_PC_Zero_Out : std_logic;
	signal s_shifted_offset : std_logic_vector(31 downto 0);
	signal s_branchaddress: std_logic_vector(31 downto 0);
	
	--ID/EX
	signal s_MemtoRegEX :std_logic;
	signal s_RegWrEX :std_logic;
	signal s_MemWriteEX : std_logic;
	signal s_MemReadEX :std_logic;
	signal s_extendedimmediateEX :std_logic_vector(31 downto 0);
	signal s_InstEX :std_logic_vector(31 downto 0);
	signal s_rsDataEX : std_logic_vector(31 downto 0);
	signal s_rtDataEX : std_logic_vector(31 downto 0);
	signal s_ALUSrcEX :std_logic;
	signal s_rsAddrEX :std_logic_vector(4 downto 0);
	signal s_rtAddrEX :std_logic_vector(4 downto 0);
	signal s_RegWrAddrEX :std_logic_vector(4 downto 0);
	signal s_PCEX :std_logic_vector(31 downto 0);
	signal s_unsignedOsignedEX :std_logic;
	signal s_ALUConEX :std_logic_vector(3 downto 0);
	signal s_HaltEX :std_logic;
	signal s_jalEX :std_logic;
	--ovrfl EX
	signal s_OvflEX :std_logic;
	--immOrtMUX
	signal s_B :std_logic_vector(31 downto 0);
	--ALU
	signal s_ALUOutput :std_logic_vector(31 downto 0);
	signal s_Zero_Out :std_logic;
	signal s_Overflow : std_logic;
	--Overflow
	signal s_Ovfl :std_logic;

	--MEM/WB
	signal s_MemtoRegMEM :std_logic;
	signal s_ALUOutputMEM :std_logic_vector(31 downto 0);
	signal s_RegWrMEM :std_logic;
	signal s_MemWriteMEM :std_logic;
	signal s_MemReadMEM :std_logic;
	signal s_HaltMEM :std_logic;
	signal s_OvflMEM :std_logic;
	signal s_rtDataMEM :std_logic_vector(31 downto 0);
	signal s_PCMEM :std_logic_vector(31 downto 0);
	signal s_jalMEM :std_logic;
	signal s_RegWrAddrMEM :std_logic_vector(4 downto 0);
	--mem
	signal s_DMemWr :std_logic;
	signal s_DMemAddr :std_logic_vector(31 downto 0);
	signal s_DMemData :std_logic_vector(31 downto 0);
	signal s_DMemOut :std_logic_vector(31 downto 0);

	--EX/MEM
	signal s_ALUOutputWB :std_logic_vector(31 downto 0);
	signal s_OvflWB :std_logic;
	signal s_DMemOutWB :std_logic_vector(31 downto 0);
	signal s_RegWrWB : std_logic;
	signal s_MemtoRegWB :std_logic;
	signal s_RegWrAddrWB :std_logic_vector(4 downto 0);
	
	--required signals
	signal s_RegWrAddr :std_logic_vector(4 downto 0);
	signal s_RegWr :std_logic;
	signal s_RegWrData :std_logic_vector(31 downto 0);
	
	
	
	
	
begin
	with iInstLd select
		s_IMemAddr<= s_NextInstAddr when '0',
		iInstAddr when others;
	
	s_WritePCEnL <= '1' when iInstLd = '0' else '0';
	with iRST select
		s_WritePCEn <= '0' when '1',
		s_WritePCEnL when others;
	
	PC: PCReg_N
		
		port map( 	 iIn		=>s_IMemAddr,	
			  	 iClk		=>iCLK,				-- Clock signal, synchronous for all DFFs in N-bit register
	 			 iWrEn		=>s_WritePCEn,			-- Write enable (0 if reading), synchronous for all DFFs in N-bit register
				 iReset	        =>iRST,				-- Reset signal, synchronous for all DFFs in N-bit register
				 oOut		=>s_PC
		);
	PCPlus4: NBitRCarryAdder 
	
		port map(
			i_A =>s_PC,
			i_B => x"00000004",
			i_Cin => '0', --add
			S => s_PC4,
			Cout => open
		);
	
	BranchOPC4: mux2t1_N
		
	    port map (	i_S          => s_PC_Zero_Out,
	       		i_D0         => s_PC4,
	       		i_D1         => s_branchaddress,
	       		o_O          => s_branchMUXresult
	);
	
	JumpObranchMUXresult:  mux2t1_N
		port map(
			i_S	=> s_jump,
			i_D0	=> s_branchMUXresult,
			i_D1	=> s_jumpAddr,
			o_O => s_jumpMUXresult
		);

	jrOjumpMUXresult: mux2t1_N
		port map(
			i_S =>s_ijump,
			i_D0 =>s_jumpMUXresult,
			i_D1 =>s_rsDataID,
			o_O=>s_NextInstAddr
		);


		
	IMem: instmem 
		generic map( 	ADDR_WIDTH=>10,
				DATA_WIDTH=>32)
		port map(	clk =>iCLK,
				addr=> s_IMemAddr(11 downto 2),
				data => iInstExt,
				we => iInstLd,
				re => iRST,
				q  => s_InstIF);
	s_WrEnIFID <= '1';
	s_PCStallIFID <= '0';
	IF_IDStage: iF_ID
		port map(	i_CLK=>iCLK,
				i_RST=>iRST,
				i_PCP4=>s_PC4,
				o_PCP4=> s_PC4ID,  
			        i_imem =>s_InstIF,
			        o_imem =>s_InstID,
			        i_stall =>s_WrEnIFID,
			        i_pc_stall => s_PCStallIFID,
	   			o_pc_stall => open
		);

	
	with s_InstID(31 downto 26) select
		s_HaltID<='1' when "010100",
		'0' when others;
	

	Control: ControlUnit 
		port Map(	i_opcode =>s_InstID(31 downto 26),
				i_funct => s_InstID(5 downto 0),
				o_RegDst =>s_RegDst,
				o_ALUSrc =>s_ALUsrc,
				o_MemtoReg =>s_MemtoReg,
				o_RegWrite => s_RegWrID,
				o_MemRead => s_MemRead,
				o_MemWrite => s_MemWr,
				o_PCSrc =>s_PCSrc,
				o_ALUOp => s_ALUOp,
				o_Ext => s_Ext,
				o_jump=>s_jump,
				o_ijump=>s_ijump,
				o_lb  => s_lb,
				o_lh=>s_lh,
				o_BranchCondition => s_Branch_Condition
		);
	Extend: Extender 

		port map(i_In    =>s_InstID(15 downto 0),           
		     i_C     =>s_Ext,                            
		     o_O     =>s_extendedimmediateID
		);

	
	mux4ALU: mux2t1_N
		generic Map (N=>6)
		port map(
			i_S => s_ALUsrc,	--control
			i_D0 => s_InstID(5 downto 0),	--funct
			i_D1=> s_InstID(31 downto 26),	--opcode
			o_O =>i_functOopcode		--goes to ALU
		);
	g_ALUCOntrol: ALUControl 
		port MAP(	 i_ALUOp	=>s_ALUOp,	--ALU choser
				 i_Funct	=>i_functOopcode,	--from mux
				 o_ALUCon	=>s_ALUCon	--ALUControl goes to ALU
	);
	

	with s_InstID(5 downto 0) select
		s_unsignedOsigned <='0' when "100001", 
		'1' when others;
	with s_InstID(5 downto 0) select
		s_unsignedOsigned <='0' when "100011",
		'1' when others;
	with s_InstID(31 downto 26) select
		s_unsignedOsigned <= '0' when "001111",
		'1' when others;
	with s_InstID(31 downto 26) select
		s_unsignedOsigned <= '0' when "001001",
		'1' when others;
	with s_InstID(31 downto 26) select
		s_unsignedOsigned <= '0' when "100100",
		'1' when others;
	

	s_jal<= s_jump and s_RegWr;
	g_Mux4jal: mux2t1_N
		generic map (N=> 5)
		port map(	i_S=>s_jal,	--jump and write to reg if 1 
				i_D0=>s_InstID(20 downto 16), --write address from instruction
				i_D1=>"11111",	--address that holds current pc for jal
				o_O=>s_instOjalresult 	--goes to next mux
		);

	g_MuxRegDst: mux2t1_N 
		generic map (N=> 5)
		port MAP(	i_S=>s_RegDst,                --to figure out destination register
				i_D0=>s_instOjalresult,	--either 11111 or from instruction
				i_D1=>s_InstID(15 downto 11),	--reg3
				o_O=>s_RegWrAddrID --final write address
		);

	s_RegWrAddr<=s_RegWrAddrWB;
	s_RegWr<=s_RegWrWB;
	s_RegWrData <= s_rdDataWB;
	RegisterFile: RegFile 
		generic map(N =>32)
		port map(i_WrAddr 	=>	s_RegWrAddr,      -- write port; chooses which single 32-bit register to write to
			 i_WrEnable	=>	s_RegWr,      -- enables the write port (5:32 decoder) to update register referenced at i_Wr with data
			 i_Data  	=>	s_RegWrData,  -- data to be written 
			 i_CLK		=> 	iCLK,
			 i_Rst  	=>	iRST,
			 i_RAddr1 	=>	s_InstID(25 downto 21),
			 i_RAddr2 	=>	s_InstID(20 downto 16),
			 o_Rd1	 	=>	s_rsDataID,  -- read port 1
			 o_Rd2	 	=>	s_rtDataID
	);
	
	Z: NBitRCarryAdder	
		port map(i_A=>s_rsDataID,
			i_B => s_rtDataID,
			i_Cin=> '1', --sub
			S=>s_Z,
			Cout=>open
		);
	
	with s_Z select
		s_Zero_Out<='1' when x"00000000",
		'0' when others;
	s_Zero<=s_Branch_Condition xor s_Zero_Out;
	s_PC_Zero_Out<=s_PCSrc and s_Zero;

	s_shifted_offset<= s_extendedimmediateID(29 downto 0) & "00";
	BranchAddres : NBitRCarryAdder	
		port map( i_A=>s_PC4ID,
			  i_B=>s_shifted_offset,
			  i_Cin=>'0',	--add
			  S=>s_branchaddress,
			  Cout => open
		);
	s_jumpAddr <= s_PC4ID(31 downto 28)&s_InstId(25 downto 0)&"00";
	
	ID_EX_Holder: ID_EX 
	  port map(i_CLK        =>iCLK,
	       i_RST        =>iRST,
	
	       i_MemtoRegEx         =>s_MemtoReg,
	       o_MemtoRegEx         =>s_MemtoRegEX,
	       i_RegWriteEx         =>s_RegWrID,
	       o_RegWriteEx         =>s_RegWrEX,
	       i_memWriteEx         =>s_MemWr,
	       o_memWriteEx         =>s_MemWriteEX,
	       i_memReadEx          =>s_MemRead,
	       o_memReadEx          =>s_MemReadEx,
	
	       i_branchEx          =>s_Branch_Condition,
	       o_branchEx          =>open,
	       i_zero          =>s_unsignedOsigned,
	       o_zero          =>s_unsignedOsignedEX,
	       i_jumpEx          => s_jump,
	       o_jumpEx          => open,
	       i_AluSrcEx          => s_ALUSrc,
	       o_AluSrcEx          =>s_ALUSrcEX,
	       i_ctlEx          =>s_Ext,
	       o_ctlEx          =>open,
	       i_jLinkEX          =>s_jal,
	       o_jLinkEX          =>s_jalEX,
	       i_jRegEX          => s_ijump,
	       o_jRegEX          =>open,
		i_ALUOpEx =>s_ALUCon,
		o_ALUOpEx =>s_ALUConEX,
	
	       i_halt          =>s_HaltID,
	       o_halt          =>s_HaltEX,
	
		i_SoZEx		=>s_Ext,
		o_SoZEx 	=>open,
	
	       i_Reg1          =>s_rsDataID,
	       o_Reg1          =>s_rsDataEX,
	       i_Reg2          =>s_rtDataID,
	       o_Reg2          =>s_rtDataEX,
	
	       i_PCEX          =>s_PC,
	       o_PCEX          =>s_PCEX,
	
	       i_signExtend          =>s_extendedimmediateID,
	       o_signExtend          =>s_extendedimmediateEX,
	
		i_InstALU		=>s_InstID,
		o_InstALU		=>s_InstEX,
	
	       i_rs          =>s_InstID(25 downto 21),
	       o_rs          =>s_rsAddrEX,    
	       i_rt          =>s_InstID(20 downto 16),
	       o_rt          => s_rtAddrEX,
	
	       i_rd          =>s_RegWrAddrID,
	       o_rd          =>s_RegWrAddrEX,

		
		i_stall		=> s_WrEnIFID
	);
	
	immOrt: mux2t1_N
		port map(	
			i_S =>s_ALUSrcEX,
			i_D0 =>s_rtDataEX,
			i_D1 =>s_extendedimmediateEX,
			o_O =>s_B
		);
	
	g_ALU: AddSub_N
		generic MAP(N => 32)
		port MAP(        i_A			=> s_rsDataEX,	--data from reg1
				 i_B			=> s_B,		--data from mux
				 i_nAdd_Sub 	        => s_ALUConEX,	--data from ALU Control
				 i_shamt		=> s_InstEX(10 downto 6), --data amount
				 o_Sums			=> s_ALUOutput,	--ALU OUTPUT
				 o_Zero_Out		=> s_Zero_Out,  --to see if sum is 0 goes to s_Zero
				 o_Carry_Out		=> open,
				 o_Overflow		=> s_Overflow
		); 

	s_OvflEX <= s_unsignedOsignedEX and s_Overflow;
	
	MEM_WB_Holder: MEM_WB 
	  port map(i_CLK        =>iCLK,
	       i_RST        =>iRST,
	
	       i_MemtoRegM          =>s_MemtoRegEX,
	       o_MemtoRegM          =>s_MemtoRegMEM,
	       i_RegWriteM          =>s_RegWrEX,
	       o_RegWriteM          =>s_RegWrMEM,
	
	       i_memWriteM          =>s_MemWriteEX,
	       o_memWriteM          =>s_MemWriteMEM,
	       i_memReadM           =>s_MemReadEX,
	       o_memReadM           =>s_MemReadMEM,
	
	       i_halt          =>s_HaltEX,
	       o_halt          =>s_HaltMEM,
	       i_jLinkM          =>s_jalEX,
	       o_jLinkM          =>s_jalMEM,
	       i_OverflowM          =>s_OvflEX,
	       o_OverflowM          =>s_OvflMEM,
		
	
	
	       i_PCM          =>s_PCEX,
	       o_PCM          =>s_PCMEM,
	
	       i_ALU          =>s_ALUOutput,
	       o_ALU          =>s_ALUOutputMEM,
	       i_ALU2         =>s_rtDataEX,
	       o_ALU2         =>s_rtDataMEM,
	
	       i_Inst          =>s_RegWrAddrEX,
	       o_Inst          =>s_RegWrAddrMEM
	);

	s_DMemWr <=s_MemWriteMEM;
	s_DMemAddr <=s_ALUOutputMEM;
	s_DMemData <=s_rtDataMEM;
	
	 DMem: mem
	    generic map(ADDR_WIDTH => 10,
	                DATA_WIDTH => 32)
	    port map(clk  => iCLK,
	             addr => s_DMemAddr(9 downto 0),
	             data => s_DMemData,
	             we   => s_DMemWr,
		     re => s_MemReadMEM,
	             q    => s_DMemOut);


	
	
	       
	EX_MEM_Holder: EX_MEM 
 	 port map(i_CLK        =>iCLK,
 	      i_RST        =>iRST,
	
 	      i_MemtoRegWB          =>s_MemtoRegMEM,
 	      o_MemtoRegWB          =>s_MemtoRegWB,
 	      i_RegWriteWB          =>s_RegWrMEM,
 	      o_RegWriteWB          =>s_RegWrWB,
	
 	      i_halt          =>s_HaltMEM,
 	      o_halt          =>s_Halt,
 	      i_jLinkWB          =>s_jalMEM,
 	      o_jLinkWB          =>open,
 	      i_OverflowWB          =>s_OvflMEM,
 	      o_OverflowWB          =>s_OvflWB,
	
 	      i_PCWB         =>s_PCMEM,
 	      o_PCWB         =>open,
	
 	      i_ALU          =>s_ALUOutputMEM,
 	      o_ALU          =>s_ALUOutputWB,
 	      i_Dmem          =>s_DMemOut,
 	      o_Dmem          =>s_DMemOutWB,
	
 	      i_Inst          =>s_RegWrAddrMEM,
 	      o_Inst          =>s_RegWrAddrWB
	);
 	      
	g_memOrRegMux: mux2t1_N 
		generic MAP(N => 32)
		port MAP(	 i_S	=> s_MemtoRegWB,
			 	 i_D0	=> s_ALUOutputWB,
				 i_D1	=> s_DMemOutWB,
				 o_O	=> s_rdDataWB);	--goes to mux

	with s_MemtoRegWB select
		s_Ovfl<= s_OvflWB when '0',
		'0' when others;

	
end structural;

    </code></pre>
    

    <footer>
        <div class="d-flex justify-content-between align-items-center px-4">
            <div class="contact">
                <h5>Contact Information</h5>
                    <div class="d-flex flex-column gap-0">
                        <p class="m-0">Annie O'Connor</p>
                        <p class="m-0">Computer Engineering Junior</p>
                        <p class="m-0">Iowa State University</p>
                        <p class="m-0">annieo10@iastate.edu</p>
                        <p class="m-0">annieom7@gmail.com</p>
                    </div>
                        
            </div>   
            <div>
                <img
                    src="icons/symbol.png"
                    alt="Symbol icon"
                    width="150vh"
                    height="150vh"
                >
            </div>
        </div>
            
        
        <div class="d-flex border-top">
            <p >&copy; 2026 Annie O'Connor All rights reserved.</p>
         </div>
    </footer>
    
</body>
</html>